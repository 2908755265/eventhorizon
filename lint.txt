golangci-lint run ./...
eventbus/local/eventbus.go:143:6: `evt` is unused (deadcode)
type evt struct {
     ^
eventbus/gcp/eventbus.go:119:2: `eventTypeAttribute` is unused (deadcode)
	eventTypeAttribute     = "event_type"
	^
eventhandler/projector/eventhandler_test.go:288: 288-315 lines are duplicate of `eventhandler/projector/eventhandler_test.go:317-344` (dupl)
func TestEventHandler_LoadError(t *testing.T) {
	repo := &mocks.Repo{}
	projector := &TestProjector{}
	handler := NewEventHandler(projector, repo)
	handler.SetEntityFactory(func() eh.Entity {
		return &mocks.SimpleModel{}
	})

	ctx := context.Background()

	// Driver creates entity.
	id := uuid.New()
	eventData := &mocks.EventData{Content: "event1"}
	timestamp := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)
	event := eh.NewEvent(mocks.EventType, eventData, timestamp,
		eh.ForAggregate(mocks.AggregateType, id, 1))
	loadErr := errors.New("load error")
	repo.LoadErr = loadErr
	expectedErr := Error{
		Err:          loadErr,
		Projector:    TestProjectorType.String(),
		EventVersion: 1,
	}
	err := handler.HandleEvent(ctx, event)
	if !errors.Is(err, expectedErr) {
		t.Error("there should be an error:", err)
	}
}
eventhandler/projector/eventhandler_test.go:317: 317-344 lines are duplicate of `eventhandler/projector/eventhandler_test.go:346-373` (dupl)
func TestEventHandler_SaveError(t *testing.T) {
	repo := &mocks.Repo{}
	projector := &TestProjector{}
	handler := NewEventHandler(projector, repo)
	handler.SetEntityFactory(func() eh.Entity {
		return &mocks.SimpleModel{}
	})

	ctx := context.Background()

	// Driver creates entity.
	id := uuid.New()
	eventData := &mocks.EventData{Content: "event1"}
	timestamp := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)
	event := eh.NewEvent(mocks.EventType, eventData, timestamp,
		eh.ForAggregate(mocks.AggregateType, id, 1))
	saveErr := errors.New("save error")
	repo.SaveErr = saveErr
	expectedErr := Error{
		Err:          saveErr,
		Projector:    TestProjectorType.String(),
		EventVersion: 1,
	}
	err := handler.HandleEvent(ctx, event)
	if !errors.Is(err, expectedErr) {
		t.Error("there should be an error:", err)
	}
}
eventhandler/projector/eventhandler_test.go:346: 346-373 lines are duplicate of `eventhandler/projector/eventhandler_test.go:288-315` (dupl)
func TestEventHandler_ProjectError(t *testing.T) {
	repo := &mocks.Repo{}
	projector := &TestProjector{}
	handler := NewEventHandler(projector, repo)
	handler.SetEntityFactory(func() eh.Entity {
		return &mocks.SimpleModel{}
	})

	ctx := context.Background()

	// Driver creates entity.
	id := uuid.New()
	eventData := &mocks.EventData{Content: "event1"}
	timestamp := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)
	event := eh.NewEvent(mocks.EventType, eventData, timestamp,
		eh.ForAggregate(mocks.AggregateType, id, 1))
	projectErr := errors.New("save error")
	projector.err = projectErr
	expectedErr := Error{
		Err:          projectErr,
		Projector:    TestProjectorType.String(),
		EventVersion: 1,
	}
	err := handler.HandleEvent(ctx, event)
	if !errors.Is(err, expectedErr) {
		t.Error("there should be an error:", err)
	}
}
eventhandler_test.go:35:15: Error return value of `h.HandleEvent` is not checked (errcheck)
	h.HandleEvent(context.Background(), e)
	             ^
middleware_test.go:44:17: Error return value of `h.HandleCommand` is not checked (errcheck)
	h.HandleCommand(context.Background(), MiddlewareTestCommand{})
	               ^
middleware_test.go:77:15: Error return value of `h.HandleEvent` is not checked (errcheck)
	h.HandleEvent(context.Background(), NewEvent("test", nil, time.Now()))
	             ^
eventhandler/waiter/eventhandler_test.go:39:16: Error return value of `h.HandleEvent` is not checked (errcheck)
		h.HandleEvent(context.Background(), expectedEvent)
		             ^
middleware/eventhandler/scheduler/middleware.go:31:11: Error return value of `m.run` is not checked (errcheck)
		go m.run(ctx)
		        ^
eventhandler/saga/eventhandler_test.go:43:21: Error return value of `handler.HandleEvent` is not checked (errcheck)
	handler.HandleEvent(ctx, event)
	                   ^
commandhandler/aggregate/commandhandler_test.go:158:18: Error return value of `h.HandleCommand` is not checked (errcheck)
		h.HandleCommand(ctx, cmd)
		               ^
eventstore/memory/eventstore.go:197:14: Error return value of `copier.Copy` is not checked (errcheck)
		copier.Copy(data, event.Data())
		           ^
httputils/query.go:72:10: Error return value of `w.Write` is not checked (errcheck)
		w.Write(b)
		       ^
eventbus/nats/eventbus.go:222:11: Error return value of `msg.Nak` is not checked (errcheck)
			msg.Nak()
			       ^
eventbus/nats/eventbus.go:228:15: Error return value of `msg.AckSync` is not checked (errcheck)
			msg.AckSync()
			           ^
eventbus/nats/eventbus.go:240:11: Error return value of `msg.Nak` is not checked (errcheck)
			msg.Nak()
			       ^
eventbus/nats/eventbus.go:244:14: Error return value of `msg.AckSync` is not checked (errcheck)
		msg.AckSync()
		           ^
hack/coverage/coverage.go:30:3: use of `fmt.Println` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Println("Usage: coverage [root] [out]\n\nCollects all .coverprofile files rooted in [root] and concatenantes them into a single file at [out].\n[root] defaults to the current directory, [out] to 'coverage.out'.")
		^
hack/coverage/coverage.go:16: Function 'main' is too long (87 > 60) (funlen)
func main() {
eventbus/acceptance_testing.go:66: Function 'AcceptanceTest' has too many statements (103 > 40) (funlen)
func AcceptanceTest(t *testing.T, bus1, bus2 eh.EventBus, timeout time.Duration) {
eventbus/acceptance_testing.go:298: Function 'benchmark' is too long (70 > 60) (funlen)
func benchmark(t bench, bus eh.EventBus, numAggregates, numHandlers, numEvents int) {
repo/acceptance_testing.go:37: Function 'AcceptanceTest' has too many statements (62 > 40) (funlen)
func AcceptanceTest(t *testing.T, repo eh.ReadWriteRepo, ctx context.Context) {
command_check_test.go:24: Function 'TestCheckCommand' has too many statements (51 > 40) (funlen)
func TestCheckCommand(t *testing.T) {
aggregatestore/events/aggregatebase_test.go:56: Function 'TestAggregateEvents' has too many statements (47 > 40) (funlen)
func TestAggregateEvents(t *testing.T) {
middleware/eventhandler/scheduler/middleware_test.go:29: Function 'TestMiddleware' is too long (69 > 60) (funlen)
func TestMiddleware(t *testing.T) {
eventhandler/projector/eventhandler.go:142: Function 'HandleEvent' is too long (118 > 60) (funlen)
func (h *EventHandler) HandleEvent(ctx context.Context, event eh.Event) error {
eventhandler/projector/eventhandler_test.go:109: Function 'TestEventHandler_UpdateModelWithVersion' is too long (89 > 60) (funlen)
func TestEventHandler_UpdateModelWithVersion(t *testing.T) {
eventstore/acceptanece_testing.go:38: Function 'AcceptanceTest' has too many statements (67 > 40) (funlen)
func AcceptanceTest(t *testing.T, store eh.EventStore, ctx context.Context) []eh.Event {
eventstore/maintenance_testing.go:36: Function 'MaintenanceAcceptanceTest' has too many statements (55 > 40) (funlen)
func MaintenanceAcceptanceTest(t *testing.T, store eh.EventStore, storeMaintenance eh.EventStoreMaintenance, ctx context.Context) {
repo/version/repo_test.go:50: Function 'extraRepoTests' has too many statements (113 > 40) (funlen)
func extraRepoTests(t *testing.T, r *Repo, baseRepo *memory.Repo) {
eventstore/recorder/eventstore_test.go:30: Function 'TestEventStore' is too long (64 > 60) (funlen)
func TestEventStore(t *testing.T) {
eventstore/memory/eventstore.go:84: Function 'save' is too long (65 > 60) (funlen)
func (s *EventStore) save(ctx context.Context, events []eh.Event, originalVersion int) error {
eventbus/kafka/eventbus.go:50: Function 'NewEventBus' is too long (64 > 60) (funlen)
func NewEventBus(addr, appID string, options ...Option) (*EventBus, error) {
repo/mongodb/repo_test.go:76: Function 'extraRepoTests' is too long (88 > 60) (funlen)
func extraRepoTests(t *testing.T, r *Repo) {
eventstore/mongodb_v2/eventmaintenance.go:31: Function 'Replace' is too long (65 > 60) (funlen)
func (s *EventStore) Replace(ctx context.Context, event eh.Event) error {
eventstore/mongodb_v2/eventstore.go:121: Function 'Save' is too long (144 > 60) (funlen)
func (s *EventStore) Save(ctx context.Context, events []eh.Event, originalVersion int) error {
eventstore/mongodb_v2/eventstore_test.go:64: Function 'TestWithEventHandlerIntegration' has too many statements (43 > 40) (funlen)
func TestWithEventHandlerIntegration(t *testing.T) {
eventstore/mongodb/eventstore.go:96: Function 'Save' is too long (86 > 60) (funlen)
func (s *EventStore) Save(ctx context.Context, events []eh.Event, originalVersion int) error {
eventstore/mongodb/eventstore_test.go:63: Function 'TestWithEventHandlerIntegration' has too many statements (43 > 40) (funlen)
func TestWithEventHandlerIntegration(t *testing.T) {
eventbus/acceptance_testing.go:27: File is not `gci`-ed (gci)

eventhandler/waiter/eventhandler_test.go:22: File is not `gci`-ed (gci)

middleware/eventhandler/scheduler/middleware.go:22: File is not `gci`-ed (gci)

context.go:36:1: don't use `init` function (gochecknoinits)
func init() {
^
mocks/mocks.go:26:1: don't use `init` function (gochecknoinits)
func init() {
^
mocks/mocks.go:474:1: don't use `init` function (gochecknoinits)
func init() {
^
context_test.go:43:58: string `testval` has 3 occurrences, make it a constant (goconst)
	if val, ok := vals[contextTestKeyOneStr]; !ok || val != "testval" {
	                                                        ^
eventbus/acceptance_testing.go:169:68: string `testval` has 5 occurrences, make it a constant (goconst)
	if val, ok := mocks.ContextOne(handlerBus1.Context); ok && val == "testval" {
	                                                                  ^
eventstore/mongodb/eventmaintenance_test.go:35:10: string `localhost:27017` has 4 occurrences, make it a constant (goconst)
		addr = "localhost:27017"
		       ^
eventstore/mongodb_v2/eventmaintenance_test.go:35:10: string `localhost:27017` has 4 occurrences, make it a constant (goconst)
		addr = "localhost:27017"
		       ^
hack/coverage/coverage.go:24:2: ifElseChain: rewrite if-else to switch statement (gocritic)
	if len(args) == 1 {
	^
command_check.go:81:3: singleCaseSwitch: should rewrite switch statement to if statement (gocritic)
		switch obj := v.Interface().(type) {
		^
command_check.go:96:3: singleCaseSwitch: should rewrite switch statement to if statement (gocritic)
		switch obj := v.Interface().(type) {
		^
eventhandler/projector/eventhandler.go:249:9: elseif: can replace 'else {if cond {}}' with 'else if cond {}' (gocritic)
	} else {
	       ^
repo/version/repo.go:78:3: ifElseChain: rewrite if-else to switch statement (gocritic)
		if rrErr, ok := err.(eh.RepoError); ok &&
		^
eventstore/memory/eventstore.go:130:9: elseif: can replace 'else {if cond {}}' with 'else if cond {}' (gocritic)
	} else {
	       ^
eventbus/kafka/eventbus.go:88:3: ifElseChain: rewrite if-else to switch statement (gocritic)
		if errors.Is(err, kafka.BrokerNotAvailable) {
		^
uuid/uuid.go:7:57: Comment should end in a period (godot)
// UUID is an alias type for github.com/google/uuid.UUID
                                                        ^
command_check.go:25:60: Comment should end in a period (godot)
// is not allowed to be used in a command. See CheckCommand
                                                           ^
entity.go:25:68: Comment should end in a period (godot)
// equivalent in all their attributes, but will still be distinct."
                                                                   ^
aggregate.go:95: aggregate.go:95: Line contains TODO/BUG/FIXME: "TODO: Explore the use of reflect/gob for..." (godox)
	// TODO: Explore the use of reflect/gob for creating concrete types without
command.go:69: command.go:69: Line contains TODO/BUG/FIXME: "TODO: Explore the use of reflect/gob for..." (godox)
	// TODO: Explore the use of reflect/gob for creating concrete types without
event.go:205: event.go:205: Line contains TODO/BUG/FIXME: "TODO: Explore the use of reflect/gob for..." (godox)
	// TODO: Explore the use of reflect/gob for creating concrete types without
eventbus/acceptance_testing.go:248: eventbus/acceptance_testing.go:248: Line contains TODO/BUG/FIXME: "TODO: Test context cancellation." (godox)
	// TODO: Test context cancellation.
aggregatestore/events/aggregatebase.go:111: aggregatestore/events/aggregatebase.go:111: Line contains TODO/BUG/FIXME: "TODO: This will probably not work with a..." (godox)
		a.AggregateVersion()+len(a.events)+1), // TODO: This will probably not work with a global version.
namespace/repo.go:74: namespace/repo.go:74: Line contains TODO/BUG/FIXME: "TODO: Log/handle error." (godox)
		// TODO: Log/handle error.
eventbus/kafka/eventbus.go:35: eventbus/kafka/eventbus.go:35: Line contains TODO/BUG/FIXME: "TODO: Support multiple brokers." (godox)
	// TODO: Support multiple brokers.
eventbus/redis/eventbus.go:159: eventbus/redis/eventbus.go:159: Line contains TODO/BUG/FIXME: "TODO: Filter subscription." (godox)
	// TODO: Filter subscription.
eventbus/redis/eventbus.go:243: eventbus/redis/eventbus.go:243: Line contains TODO/BUG/FIXME: "TODO: Nack if possible." (godox)
			// TODO: Nack if possible.
eventbus/redis/eventbus.go:269: eventbus/redis/eventbus.go:269: Line contains TODO/BUG/FIXME: "TODO: Nack if possible." (godox)
			// TODO: Nack if possible.
eventbus/nats/eventbus.go:264: eventbus/nats/eventbus.go:264: Line contains TODO/BUG/FIXME: "TODO: Support eh.MatchAll in one level w..." (godox)
		// TODO: Support eh.MatchAll in one level with aggregate and event.
eventstore/mongodb/eventmaintenance.go:71: eventstore/mongodb/eventmaintenance.go:71: Line contains TODO/BUG/FIXME: "TODO: Maybe use change info." (godox)
	// TODO: Maybe use change info.
eventstore/mongodb_v2/eventmaintenance.go:102: eventstore/mongodb_v2/eventmaintenance.go:102: Line contains TODO/BUG/FIXME: "TODO: Maybe use change info." (godox)
	// TODO: Maybe use change info.
command_check_test.go:117: File is not `gofmt`-ed with `-s` (gofmt)
		TestID: uuid.New(),
hack/coverage/coverage.go:101: File is not `gofumpt`-ed (gofumpt)
	if err := ioutil.WriteFile(out, []byte(strings.Join(lines, "\n")), 0666); err != nil {
mocks/mocks.go:52: File is not `gofumpt`-ed (gofumpt)
type EmptyAggregate struct {
}
mocks/mocks.go:145: File is not `gofumpt`-ed (gofumpt)
var _ = eh.Entity(&Model{})
var _ = eh.Versionable(&Model{})
commandhandler/bus/commandhandler_test.go:34:9: should not use basic type string as key in context.WithValue (golint)
	ctx := context.WithValue(context.Background(), "testkey", "testval")
	       ^
commandhandler/aggregate/commandhandler_test.go:52:9: should not use basic type string as key in context.WithValue (golint)
	ctx := context.WithValue(context.Background(), "testkey", "testval")
	       ^
commandhandler/aggregate/commandhandler_test.go:151:9: should not use basic type string as key in context.WithValue (golint)
	ctx := context.WithValue(context.Background(), "testkey", "testval")
	       ^
eventstore/mongodb_v2/eventmaintenance.go:15:1: don't use an underscore in package name (golint)
package mongodb_v2
^
eventstore/mongodb_v2/eventmaintenance_test.go:15:1: don't use an underscore in package name (golint)
package mongodb_v2
^
eventstore/mongodb_v2/eventstore.go:15:1: don't use an underscore in package name (golint)
package mongodb_v2
^
eventbus/acceptance_testing.go:351:19: G404: Use of weak random number generator (math/rand instead of crypto/rand) (gosec)
		a := aggregates[rand.Intn(len(aggregates))]
		                ^
eventbus/redis/eventbus.go:226:21: G601: Implicit memory aliasing in for loop. (gosec)
				handler(b.cctx, &msg)
				                ^
eventbus/acceptance_testing.go:128: line is 125 characters (lll)
	if err := bus1.AddHandler(ctx, eh.MatchAll{}, eh.UseEventHandlerMiddleware(observerBus1, observer.Middleware)); err != nil {
eventbus/acceptance_testing.go:131: line is 125 characters (lll)
	if err := bus2.AddHandler(ctx, eh.MatchAll{}, eh.UseEventHandlerMiddleware(observerBus2, observer.Middleware)); err != nil {
eventhandler/waiter/eventhandler.go:90: line is 121 characters (lll)
// Inbox returns the channel that events will be delivered on so that you can integrate into your own select() if needed.
aggregatestore/events/aggregatebase.go:107: line is 129 characters (lll)
func (a *AggregateBase) AppendEvent(t eh.EventType, data eh.EventData, timestamp time.Time, options ...eh.EventOption) eh.Event {
codec/bson/codec_test.go:26: line is 702 characters (lll)
	expectedBytes, err := base64.StdEncoding.DecodeString("4QEAAAJldmVudF90eXBlAAsAAABDb2RlY0V2ZW50AANkYXRhAAwBAAAIYm9vbAABAnN0cmluZwAHAAAAc3RyaW5nAAFudW1iZXIAAAAAAAAARUAEc2xpY2UAFwAAAAIwAAIAAABhAAIxAAIAAABiAAADbWFwABQAAAACa2V5AAYAAAB2YWx1ZQAACXRpbWUAgDVT4CQBAAAJdGltZXJlZgCANVPgJAEAAApudWxsdGltZQADc3RydWN0AC8AAAAIYm9vbAABAnN0cmluZwAHAAAAc3RyaW5nAAFudW1iZXIAAAAAAAAARUAAA3N0cnVjdHJlZgAvAAAACGJvb2wAAQJzdHJpbmcABwAAAHN0cmluZwABbnVtYmVyAAAAAAAAAEVAAApudWxsc3RydWN0AAAJdGltZXN0YW1wAIA1U+AkAQAAAmFnZ3JlZ2F0ZV90eXBlAAoAAABBZ2dyZWdhdGUAAl9pZAAlAAAAMTBhN2VjMGYtN2YyYi00NmY1LWJjYTEtODc3YjZlMzNjOWZkABB2ZXJzaW9uAAEAAAADbWV0YWRhdGEAEgAAAAFudW0AAAAAAAAARUAAA2NvbnRleHQAHgAAAAJjb250ZXh0X29uZQAIAAAAdGVzdHZhbAAAAA==")
eventbus/kafka/eventbus.go:287: line is 145 characters (lll)
func (b *EventBus) handler(m eh.EventMatcher, h eh.EventHandler, r *kafka.Reader) func(ctx context.Context, msg kafka.Message) eh.EventBusError {
eventbus/redis/eventbus.go:232: line is 131 characters (lll)
func (b *EventBus) handler(m eh.EventMatcher, h eh.EventHandler, groupName string) func(ctx context.Context, msg *redis.XMessage) {
repo/mongodb/repo.go:208: line is 136 characters (lll)
func (r *Repo) FindCustomIter(ctx context.Context, f func(context.Context, *mongo.Collection) (*mongo.Cursor, error)) (eh.Iter, error) {
repo/mongodb/repo.go:239: line is 138 characters (lll)
func (r *Repo) FindCustom(ctx context.Context, f func(context.Context, *mongo.Collection) (*mongo.Cursor, error)) ([]interface{}, error) {
eventbus.go:25:19: `garanteed` is a misspelling of `guaranteed` (misspell)
// Events are not garanteed to be handeled in order.
                  ^
codec/acceptance_testing.go:56:83: `comparisson` is a misspelling of `comparisons` (misspell)
		Map:     map[string]interface{}{"key": "value"}, // NOTE: Just one key to avoid comparisson issues.
		                                                                                ^
codec/acceptance_testing.go:72:88: `comparisson` is a misspelling of `comparisons` (misspell)
		eh.WithMetadata(map[string]interface{}{"num": 42.0}), // NOTE: Just one key to avoid comparisson issues.
		                                                                                     ^
eventhandler/projector/eventhandler.go:177:2: `if ok` is deeply nested (complexity: 7) (nestif)
	if entity, ok := entity.(eh.Versionable); ok {
	^
httputils/query.go:44:3: `if idStr == ""` is deeply nested (complexity: 6) (nestif)
		if idStr == "" {
		^
hack/coverage/coverage.go:95:2: Consider preallocating `lines` (prealloc)
	var lines []string
	^
eventbus_test.go:60:12: Using the variable on range scope `tc` in function literal (scopelint)
				Err:   tc.err,
				       ^
eventbus_test.go:61:12: Using the variable on range scope `tc` in function literal (scopelint)
				Event: tc.event,
				       ^
eventbus_test.go:64:27: Using the variable on range scope `tc` in function literal (scopelint)
			if busError.Error() != tc.expectedErrorText {
			                       ^
command_check_test.go:288:2: `private` is unused (structcheck)
	private string
	^
eventbus/local/eventbus.go:144:2: `ctxVals` is unused (structcheck)
	ctxVals map[string]interface{}
	^
eventbus/local/eventbus.go:145:2: `event` is unused (structcheck)
	event   eh.Event
	^
uuid/uuid.go:11:15: unnecessary conversion (unconvert)
var Nil = UUID(uuid.Nil)
              ^
uuid/uuid.go:15:13: unnecessary conversion (unconvert)
	return UUID(uuid.New())
	           ^
uuid/uuid.go:21:13: unnecessary conversion (unconvert)
	return UUID(id), err
	           ^
eventbus/local/eventbus.go:216:25: `(*Group).publish` - `ctx` is unused (unparam)
func (g *Group) publish(ctx context.Context, b []byte) error {
                        ^
eventstore/memory/eventstore.go:187:16: `copyEvent` - `ctx` is unused (unparam)
func copyEvent(ctx context.Context, event eh.Event) (eh.Event, error) {
               ^
eventbus/nats/eventbus.go:197:27: `(*EventBus).handle` - `sub` is unused (unparam)
func (b *EventBus) handle(sub *nats.Subscription) {
                          ^
eventstore/mongodb_v2/eventstore.go:348:13: `newEvt` - `ctx` is unused (unparam)
func newEvt(ctx context.Context, event eh.Event) (*evt, error) {
            ^
eventstore/mongodb/eventstore.go:260:13: `newEvt` - `ctx` is unused (unparam)
func newEvt(ctx context.Context, event eh.Event) (*evt, error) {
            ^
hack/coverage/coverage.go:20:2: only one cuddle assignment allowed before if statement (wsl)
	if err != nil {
	^
hack/coverage/coverage.go:23:2: assignments should only be cuddled with other assignments (wsl)
	out := "coverage.out"
	^
hack/coverage/coverage.go:42:2: if statements should only be cuddled with assignments used in the if statement itself (wsl)
	if err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
	^
hack/coverage/coverage.go:99:2: expressions should not be cuddled with blocks (wsl)
	sort.Strings(lines)
	^
aggregate.go:94:59: block should not start with a whitespace (wsl)
func RegisterAggregate(factory func(uuid.UUID) Aggregate) {
                                                          ^
aggregate.go:103:2: assignments should only be cuddled with other assignments (wsl)
	aggregateType := aggregate.AggregateType()
	^
aggregate.go:104:2: only one cuddle assignment allowed before if statement (wsl)
	if aggregateType == AggregateType("") {
	^
aggregate.go:110:2: if statements should only be cuddled with assignments (wsl)
	if _, ok := aggregates[aggregateType]; ok {
	^
aggregate.go:113:2: assignments should only be cuddled with other assignments (wsl)
	aggregates[aggregateType] = factory
	^
aggregate.go:121:2: if statements should only be cuddled with assignments (wsl)
	if factory, ok := aggregates[aggregateType]; ok {
	^
aggregate.go:124:2: return statements should not be cuddled if block has more than two lines (wsl)
	return nil, ErrAggregateNotRegistered
	^
command.go:68:46: block should not start with a whitespace (wsl)
func RegisterCommand(factory func() Command) {
                                             ^
command.go:78:2: only one cuddle assignment allowed before if statement (wsl)
	if commandType == CommandType("") {
	^
command.go:84:2: if statements should only be cuddled with assignments (wsl)
	if _, ok := commands[commandType]; ok {
	^
command.go:103:2: expressions should not be cuddled with blocks (wsl)
	delete(commands, commandType)
	^
command.go:114:2: return statements should not be cuddled if block has more than two lines (wsl)
	return nil, ErrCommandNotRegistered
	^
command_check.go:68:2: return statements should not be cuddled if block has more than two lines (wsl)
	return nil
	^
command_check.go:85:3: for statements should only be cuddled with assignments used in the iteration (wsl)
		for i := 0; i < v.Len(); i++ {
		^
command_check.go:103:3: for statements should only be cuddled with assignments used in the iteration (wsl)
		for i := 0; i < v.NumField(); i++ {
		^
compare.go:61:3: expressions should not be cuddled with blocks (wsl)
		o(&opts)
		^
compare.go:57:2: ranges should only be cuddled with assignments used in the iteration (wsl)
	for _, o := range options {
	^
compare.go:90:3: ranges should only be cuddled with assignments used in the iteration (wsl)
		for k, v := range e1.Metadata() {
		^
compare.go:97:3: only one cuddle assignment allowed before range statement (wsl)
		for k, v := range e2.Metadata() {
		^
compare.go:115:2: ranges should only be cuddled with assignments used in the iteration (wsl)
	for i, e1 := range evts1 {
	^
context.go:122:2: append only allowed to cuddle with appended value (wsl)
	contextMarshalFuncs = append(contextMarshalFuncs, f)
	^
context.go:155:2: append only allowed to cuddle with appended value (wsl)
	contextUnmarshalFuncs = append(contextUnmarshalFuncs, f)
	^
event.go:204:71: block should not start with a whitespace (wsl)
func RegisterEventData(eventType EventType, factory func() EventData) {
                                                                      ^
mocks/mocks.go:91:2: append only allowed to cuddle with appended value (wsl)
	a.Commands = append(a.Commands, cmd)
	^
eventbus/acceptance_testing.go:148:2: if statements should only be cuddled with assignments used in the if statement itself (wsl)
	if !(handlerBus1.Wait(timeout) || handlerBus2.Wait(timeout)) {
	^
eventbus/acceptance_testing.go:260:2: for statement without condition should never be cuddled (wsl)
	for {
	^
eventbus/acceptance_testing.go:320:4: for statement without condition should never be cuddled (wsl)
			for {
			^
eventbus/acceptance_testing.go:317:3: go statements can only invoke functions assigned on line above (wsl)
		go func(h *mocks.EventHandler) {
		^
eventbus/acceptance_testing.go:342:2: for statements should only be cuddled with assignments used in the iteration (wsl)
	for i := 0; i < numAggregates; i++ {
	^
middleware/commandhandler/validate/middleware_test.go:55:2: declarations should never be cuddled (wsl)
	var validateErr Error
	^
aggregatestore/model/aggregatestore.go:84:3: only one cuddle assignment allowed before range statement (wsl)
		for _, e := range events {
		^
aggregatestore/model/aggregatestore_test.go:171:2: only cuddled expressions if assigning variable or using from line above (wsl)
	agg.AppendEvent(event)
	^
eventhandler/waiter/eventhandler.go:119:6: block should not end with a whitespace (or comment) (wsl)
					}
					^
eventhandler/waiter/eventhandler.go:102:2: for statement without condition should never be cuddled (wsl)
	for {
	^
eventhandler/waiter/eventhandler_test.go:37:2: only one cuddle assignment allowed before go statement (wsl)
	go func() {
	^
eventhandler/waiter/eventhandler_test.go:63:2: go statements can only invoke functions assigned on line above (wsl)
	go func() {
	^
eventhandler/saga/eventhandler_test.go:69:2: only one cuddle assignment allowed before range statement (wsl)
	for _, cmd := range m.commands {
	^
eventhandler/projector/eventhandler.go:152:4: only one cuddle assignment allowed before defer statement (wsl)
			defer cancel()
			^
eventhandler/projector/eventhandler.go:149:3: if statements should only be cuddled with assignments used in the if statement itself (wsl)
		if h.useWait {
		^
eventhandler/projector/eventhandler_test.go:234:2: only one cuddle assignment allowed before go statement (wsl)
	go func() {
	^
commandhandler/aggregate/commandhandler_test.go:102:2: declarations should never be cuddled (wsl)
	var aggregateErr eh.AggregateError
	^
middleware/commandhandler/scheduler/middleware_test.go:106:2: declarations should never be cuddled (wsl)
	var err Error
	^
middleware/commandhandler/scheduler/middleware_test.go:160:2: only one cuddle assignment allowed before defer statement (wsl)
	defer cancel()
	^
repo/version/repo_test.go:133:2: only one cuddle assignment allowed before defer statement (wsl)
	defer cancel()
	^
repo/version/repo_test.go:195:2: go statements can only invoke functions assigned on line above (wsl)
	go func() {
	^
namespace/eventstore.go:104:2: only cuddled expressions if assigning variable or using from line above (wsl)
	s.eventStoresMu.RLock()
	^
command_check.go:71:1: calculated cyclomatic complexity for function isZero is 14, max is 10 (cyclop)
func isZero(v reflect.Value) bool {
^
compare.go:55:1: calculated cyclomatic complexity for function CompareEvents is 17, max is 10 (cyclop)
func CompareEvents(e1, e2 Event, options ...CompareOption) error {
^
event_test.go:26:1: calculated cyclomatic complexity for function TestNewEvent is 14, max is 10 (cyclop)
func TestNewEvent(t *testing.T) {
^
eventbus/gcp/eventbus.go:146:1: calculated cyclomatic complexity for function AddHandler is 12, max is 10 (cyclop)
func (b *EventBus) AddHandler(ctx context.Context, m eh.EventMatcher, h eh.EventHandler) error {
^
eventbus/kafka/eventbus.go:233:1: calculated cyclomatic complexity for function handle is 15, max is 10 (cyclop)
func (b *EventBus) handle(m eh.EventMatcher, h eh.EventHandler, r *kafka.Reader) {
^
eventbus/local/eventbus.go:149:1: calculated cyclomatic complexity for function handle is 11, max is 10 (cyclop)
func (b *EventBus) handle(m eh.EventMatcher, h eh.EventHandler, ch <-chan []byte) {
^
eventhandler/waiter/eventhandler.go:100:1: calculated cyclomatic complexity for function run is 11, max is 10 (cyclop)
func (h *EventHandler) run() {
^
eventstore/memory/eventstore_test.go:40:1: calculated cyclomatic complexity for function TestWithEventHandler is 11, max is 10 (cyclop)
func TestWithEventHandler(t *testing.T) {
^
middleware/commandhandler/async/middleware_test.go:29:1: calculated cyclomatic complexity for function TestMiddleware is 12, max is 10 (cyclop)
func TestMiddleware(t *testing.T) {
^
middleware/eventhandler/async/middleware_test.go:29:1: calculated cyclomatic complexity for function TestMiddleware is 12, max is 10 (cyclop)
func TestMiddleware(t *testing.T) {
^
repo/version/repo.go:61:1: calculated cyclomatic complexity for function Find is 11, max is 10 (cyclop)
func (r *Repo) Find(ctx context.Context, id uuid.UUID) (eh.Entity, error) {
^
eventbus/acceptance_testing.go:38:76: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err := bus1.AddHandler(ctx, nil, mocks.NewEventHandler("no-matcher")); err != eh.ErrMissingMatcher {
	                                                                          ^
eventbus/acceptance_testing.go:43:54: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err := bus1.AddHandler(ctx, eh.MatchAll{}, nil); err != eh.ErrMissingHandler {
	                                                    ^
eventstore/acceptanece_testing.go:46:18: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	if esErr, ok := err.(eh.EventStoreError); !ok || esErr.Err != eh.ErrNoEventsToAppend {
	                ^
eventstore/acceptanece_testing.go:66:18: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	if esErr, ok := err.(eh.EventStoreError); !ok || esErr.Err != eh.ErrIncorrectEventVersion {
	                ^
eventstore/maintenance_testing.go:56:66: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	if err := storeMaintenance.Replace(ctx, eventWithoutAggregate); err != eh.ErrAggregateNotFound {
	                                                                ^
repo/acceptance_testing.go:40:18: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	if rrErr, ok := err.(eh.RepoError); !ok || rrErr.Err != eh.ErrEntityNotFound {
	                ^
eventbus/local/eventbus.go:177:74: non-wrapping format verb for fmt.Errorf. Use `%w` to format errors (errorlint)
				err = fmt.Errorf("could not handle event (%s): %s", h.HandlerType(), err.Error())
				                                                                     ^
eventstore/memory/eventstore.go:43:62: non-wrapping format verb for fmt.Errorf. Use `%w` to format errors (errorlint)
			return nil, fmt.Errorf("error while applying option: %v", err)
			                                                          ^
eventstore/mongodb_v2/eventmaintenance.go:63:7: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
			if res.Err() == mongo.ErrNoDocuments {
			   ^
eventstore/mongodb_v2/eventmaintenance.go:87:6: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
		if err == eh.ErrAggregateNotFound || err == eh.ErrInvalidEvent {
		   ^
eventstore/mongodb_v2/eventstore.go:94:12: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error (errorlint)
	}).Err(); err == mongo.ErrNoDocuments {
	          ^
repo/mongodb/repo.go:338:51: non-wrapping format verb for fmt.Errorf. Use `%w` to format errors (errorlint)
		return fmt.Errorf("could not create index: %s", err)
		                                                ^
codec/bson/uuid.go:51:4: missing cases in switch of type bsontype.Type: Array, Binary, Boolean, CodeWithScope, DBPointer, DateTime, Decimal128, Double, EmbeddedDocument, Int32, Int64, JavaScript, MaxKey, MinKey, Null, ObjectID, Regex, Symbol, Timestamp, Undefined (exhaustive)
			switch vr.Type() {
			^
codec/acceptance_testing.go:28:64: Bool, String, Number, Slice, Map, Time, TimeRef, NullTime, Struct, StructRef, NullStruct are missing in EventData (exhaustivestruct)
	eh.RegisterEventData(EventType, func() eh.EventData { return &EventData{} })
	                                                              ^
codec/acceptance_testing.go:51:15: NullTime, NullStruct are missing in EventData (exhaustivestruct)
	eventData := EventData{
	             ^
httputils/eventbus.go:40:10: upgrader, chs, chsMu are missing in EventBusHandler (exhaustivestruct)
	return &EventBusHandler{
	        ^
repo/acceptance_testing.go:57:22: ID, Version are missing in Model (exhaustivestruct)
	entityMissingID := &mocks.Model{
	                    ^
repo/acceptance_testing.go:67:14: Version is missing in Model (exhaustivestruct)
	entity1 := &mocks.Model{
	            ^
repo/acceptance_testing.go:96:17: Version is missing in Model (exhaustivestruct)
	entity1Alt := &mocks.Model{
	               ^
repo/acceptance_testing.go:113:14: Version is missing in Model (exhaustivestruct)
	entity2 := &mocks.Model{
	            ^
event.go:120:8: aggregateType, aggregateID, version, metadata are missing in event (exhaustivestruct)
	e := &event{
	      ^
aggregate_test.go:93:20: id is missing in TestAggregateRegister (exhaustivestruct)
var _ = Aggregate(&TestAggregateRegister{})
                   ^
aggregate_test.go:108:20: id is missing in TestAggregateRegisterEmpty (exhaustivestruct)
var _ = Aggregate(&TestAggregateRegisterEmpty{})
                   ^
aggregate_test.go:123:20: id is missing in TestAggregateRegisterTwice (exhaustivestruct)
var _ = Aggregate(&TestAggregateRegisterTwice{})
                   ^
command_check_test.go:32:22: Content is missing in TestCommandUUIDValue (exhaustivestruct)
	err = CheckCommand(&TestCommandUUIDValue{TestID: uuid.New()})
	                    ^
command_check_test.go:38:22: Content is missing in TestCommandStringValue (exhaustivestruct)
	err = CheckCommand(&TestCommandStringValue{TestID: uuid.New()})
	                    ^
command_check_test.go:44:22: Content is missing in TestCommandIntValue (exhaustivestruct)
	err = CheckCommand(&TestCommandIntValue{TestID: uuid.New()})
	                    ^
command_check_test.go:50:22: Content is missing in TestCommandFloatValue (exhaustivestruct)
	err = CheckCommand(&TestCommandFloatValue{TestID: uuid.New()})
	                    ^
command_check_test.go:56:22: Content is missing in TestCommandBoolValue (exhaustivestruct)
	err = CheckCommand(&TestCommandBoolValue{TestID: uuid.New()})
	                    ^
command_check_test.go:62:22: Content is missing in TestCommandUIntPtrValue (exhaustivestruct)
	err = CheckCommand(&TestCommandUIntPtrValue{TestID: uuid.New()})
	                    ^
command_check_test.go:68:22: Slice is missing in TestCommandSlice (exhaustivestruct)
	err = CheckCommand(&TestCommandSlice{TestID: uuid.New()})
	                    ^
command_check_test.go:74:22: Map is missing in TestCommandMap (exhaustivestruct)
	err = CheckCommand(&TestCommandMap{TestID: uuid.New()})
	                    ^
command_check_test.go:80:22: Struct is missing in TestCommandStruct (exhaustivestruct)
	err = CheckCommand(&TestCommandStruct{TestID: uuid.New()})
	                    ^
command_check_test.go:86:22: Time is missing in TestCommandTime (exhaustivestruct)
	err = CheckCommand(&TestCommandTime{TestID: uuid.New()})
	                    ^
command_check_test.go:92:22: Content is missing in TestCommandOptional (exhaustivestruct)
	err = CheckCommand(&TestCommandOptional{TestID: uuid.New()})
	                    ^
command_check_test.go:98:22: private is missing in TestCommandPrivate (exhaustivestruct)
	err = CheckCommand(&TestCommandPrivate{TestID: uuid.New()})
	                    ^
command_check_test.go:141:17: TestID, Content are missing in TestCommandFields (exhaustivestruct)
var _ = Command(TestCommandFields{})
                ^
command_check_test.go:154:17: TestID, Content are missing in TestCommandUUIDValue (exhaustivestruct)
var _ = Command(TestCommandUUIDValue{})
                ^
command_check_test.go:167:17: TestID, Content are missing in TestCommandStringValue (exhaustivestruct)
var _ = Command(TestCommandStringValue{})
                ^
command_check_test.go:180:17: TestID, Content are missing in TestCommandIntValue (exhaustivestruct)
var _ = Command(TestCommandIntValue{})
                ^
command_check_test.go:193:17: TestID, Content are missing in TestCommandFloatValue (exhaustivestruct)
var _ = Command(TestCommandFloatValue{})
                ^
command_check_test.go:206:17: TestID, Content are missing in TestCommandBoolValue (exhaustivestruct)
var _ = Command(TestCommandBoolValue{})
                ^
command_check_test.go:219:17: TestID, Content are missing in TestCommandUIntPtrValue (exhaustivestruct)
var _ = Command(TestCommandUIntPtrValue{})
                ^
command_check_test.go:232:17: TestID, Slice are missing in TestCommandSlice (exhaustivestruct)
var _ = Command(TestCommandSlice{})
                ^
command_check_test.go:243:17: TestID, Map are missing in TestCommandMap (exhaustivestruct)
var _ = Command(TestCommandMap{})
                ^
command_check_test.go:256:17: TestID, Struct are missing in TestCommandStruct (exhaustivestruct)
var _ = Command(TestCommandStruct{})
                ^
command_check_test.go:267:17: TestID, Time are missing in TestCommandTime (exhaustivestruct)
var _ = Command(TestCommandTime{})
                ^
command_check_test.go:278:17: TestID, Content are missing in TestCommandOptional (exhaustivestruct)
var _ = Command(TestCommandOptional{})
                ^
command_check_test.go:291:17: TestID, private are missing in TestCommandPrivate (exhaustivestruct)
var _ = Command(TestCommandPrivate{})
                ^
command_check_test.go:306:17: TestID, StringArray, IntArray, StructArray are missing in TestCommandArray (exhaustivestruct)
var _ = Command(TestCommandArray{})
                ^
command_check_test.go:320:17: TestID, TestZeroableInt, TestInt are missing in TestCommandZeroableInt (exhaustivestruct)
var _ = Command(TestCommandZeroableInt{})
                ^
event_test.go:185:17: TestID, Content, CmdID are missing in TestCommandID (exhaustivestruct)
var _ = Command(TestCommandID{})
                ^
eventbus_test.go:59:16: Ctx is missing in EventBusError (exhaustivestruct)
			busError := EventBusError{
			            ^
aggregatestore/events/aggregatebase.go:68:10: v, events are missing in AggregateBase (exhaustivestruct)
	return &AggregateBase{
	        ^
aggregatestore/events/aggregatebase_test.go:130:77: Content is missing in TestEventData (exhaustivestruct)
	eh.RegisterEventData(TestAggregateEventType, func() eh.EventData { return &TestEventData{} })
	                                                                           ^
aggregatestore/events/aggregatebase_test.go:144:20: TestID, Content are missing in TestAggregateCommand (exhaustivestruct)
var _ = eh.Command(TestAggregateCommand{})
                   ^
aggregatestore/events/aggregatebase_test.go:159:29: AggregateBase, event are missing in TestAggregate (exhaustivestruct)
var _ = VersionedAggregate(&TestAggregate{})
                            ^
aggregatestore/events/aggregatebase_test.go:162:10: event is missing in TestAggregate (exhaustivestruct)
	return &TestAggregate{
	        ^
aggregatestore/events/aggregatestore_test.go:30:17: Loaded, Context, Err are missing in EventStore (exhaustivestruct)
	eventStore := &mocks.EventStore{
	               ^
aggregatestore/events/aggregatestore_test.go:217:17: Loaded, Context, Err are missing in EventStore (exhaustivestruct)
	eventStore := &mocks.EventStore{
	               ^
aggregatestore/events/aggregatestore_test.go:243:29: AggregateBase, err are missing in TestAggregateOther (exhaustivestruct)
var _ = VersionedAggregate(&TestAggregateOther{})
                            ^
aggregatestore/events/aggregatestore_test.go:246:10: err is missing in TestAggregateOther (exhaustivestruct)
	return &TestAggregateOther{
	        ^
aggregatestore/model/aggregatestore_test.go:30:11: RWMutex, ParentRepo, Entity, Entities, LoadErr, SaveErr, FindCalled, FindAllCalled, SaveCalled, RemoveCalled are missing in Repo (exhaustivestruct)
	repo := &mocks.Repo{}
	         ^
eventbus/redis/eventbus.go:234:3: type assertion must be checked (forcetypeassert)
		data := msg.Values[dataKey].(string)
		^
eventhandler/projector/eventhandler_test.go:380:4: type assertion must be checked (forcetypeassert)
			eventData := event.Data().(*mocks.EventData)
			^
eventstore/mongodb_v2/eventstore.go:184:4: type assertion must be checked (forcetypeassert)
			event := e.(*evt)
			^
aggregate.go:128:5: aggregatesMu is a global variable (gochecknoglobals)
var aggregatesMu sync.RWMutex
    ^
command.go:118:5: commandsMu is a global variable (gochecknoglobals)
var commandsMu sync.RWMutex
    ^
context.go:107:2: contextMarshalFuncs is a global variable (gochecknoglobals)
	contextMarshalFuncs   = []ContextMarshalFunc{}
	^
context.go:108:2: contextMarshalFuncsMu is a global variable (gochecknoglobals)
	contextMarshalFuncsMu = sync.RWMutex{}
	^
context.go:110:2: contextUnmarshalFuncs is a global variable (gochecknoglobals)
	contextUnmarshalFuncs   = []ContextUnmarshalFunc{}
	^
context.go:111:2: contextUnmarshalFuncsMu is a global variable (gochecknoglobals)
	contextUnmarshalFuncsMu = sync.RWMutex{}
	^
event.go:248:5: eventDataFactoriesMu is a global variable (gochecknoglobals)
var eventDataFactoriesMu sync.RWMutex
    ^
eventbus/local/eventbus.go:29:5: DefaultQueueSize is a global variable (gochecknoglobals)
var DefaultQueueSize = 1000
    ^
repo/version/context.go:26:5: DefaultMinVersionDeadline is a global variable (gochecknoglobals)
var DefaultMinVersionDeadline = 10 * time.Second
    ^
eventbus/acceptance_testing.go:224:21: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"handler error\")" (goerr113)
	errorHandler.Err = errors.New("handler error")
	                   ^
compare.go:65:10: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"incorrect event type: %s (should be %s)\", e1.EventType(), e2.EventType())" (goerr113)
		return fmt.Errorf("incorrect event type: %s (should be %s)", e1.EventType(), e2.EventType())
		       ^
compare.go:68:10: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"incorrect event data: %s (should be %s)\", e1.Data(), e2.Data())" (goerr113)
		return fmt.Errorf("incorrect event data: %s (should be %s)", e1.Data(), e2.Data())
		       ^
compare.go:72:11: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"incorrect timestamp: %s (should be %s)\", e1.Timestamp(), e2.Timestamp())" (goerr113)
			return fmt.Errorf("incorrect timestamp: %s (should be %s)", e1.Timestamp(), e2.Timestamp())
			       ^
compare.go:76:10: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"incorrect aggregate type: %s (should be %s)\", e1.AggregateType(), e2.AggregateType())" (goerr113)
		return fmt.Errorf("incorrect aggregate type: %s (should be %s)", e1.AggregateType(), e2.AggregateType())
		       ^
compare.go:79:10: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"incorrect aggregate ID: %s (should be %s)\", e1.AggregateID(), e2.AggregateID())" (goerr113)
		return fmt.Errorf("incorrect aggregate ID: %s (should be %s)", e1.AggregateID(), e2.AggregateID())
		       ^
compare.go:83:11: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"incorrect version: %d (should be %d)\", e1.Version(), e2.Version())" (goerr113)
			return fmt.Errorf("incorrect version: %d (should be %d)", e1.Version(), e2.Version())
			       ^
compare.go:105:10: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"incorrect event metadata: %s (should be %s)\", m1, m2)" (goerr113)
		return fmt.Errorf("incorrect event metadata: %s (should be %s)", m1, m2)
		       ^
eventbus_test.go:32:4: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"some error\")" (goerr113)
			errors.New("some error"),
			^
eventbus_test.go:44:4: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"some error\")" (goerr113)
			errors.New("some error"),
			^
aggregatestore/events/aggregatestore_test.go:106:14: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"error\")" (goerr113)
	storeErr := errors.New("error")
	            ^
aggregatestore/events/aggregatestore_test.go:193:12: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"error\")" (goerr113)
	agg.err = errors.New("error")
	          ^
aggregatestore/model/aggregatestore_test.go:85:14: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"error\")" (goerr113)
	storeErr := errors.New("error")
	            ^
aggregatestore/model/aggregatestore_test.go:132:18: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"aggregate error\")" (goerr113)
	aggregateErr := errors.New("aggregate error")
	                ^
aggregatestore/model/aggregatestore_test.go:169:12: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"bus error\")" (goerr113)
	busErr := errors.New("bus error")
	          ^
codec/bson/uuid.go:58:12: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"received invalid BSON type to decode into UUID: %s\", vr.Type())" (goerr113)
				return fmt.Errorf("received invalid BSON type to decode into UUID: %s", vr.Type())
				       ^
codec/bson/uuid.go:63:12: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"could not parse UUID string: %s\", s)" (goerr113)
				return fmt.Errorf("could not parse UUID string: %s", s)
				       ^
codec/bson/uuid.go:67:12: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"invalid kind of reflected UUID value: %s\", v.Kind().String())" (goerr113)
				return fmt.Errorf("invalid kind of reflected UUID value: %s", v.Kind().String())
				       ^
commandhandler/aggregate/commandhandler_test.go:95:16: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"command error\")" (goerr113)
	commandErr := errors.New("command error")
	              ^
commandhandler/aggregate/commandhandler_test.go:114:13: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"save error\")" (goerr113)
	saveErr := errors.New("save error")
	           ^
eventbus/gcp/eventbus.go:164:10: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"match filter is longer than 256 chars: %d\", len(filter))" (goerr113)
		return fmt.Errorf("match filter is longer than 256 chars: %d", len(filter))
		       ^
eventbus/gcp/eventbus.go:192:11: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"the existing filter for '%s' differs, please remove to recreate\", h.HandlerType())" (goerr113)
			return fmt.Errorf("the existing filter for '%s' differs, please remove to recreate", h.HandlerType())
			       ^
eventbus/gcp/eventbus.go:195:11: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"message ordering not enabled for subscription '%s', please remove to recreate\", h.HandlerType())" (goerr113)
			return fmt.Errorf("message ordering not enabled for subscription '%s', please remove to recreate", h.HandlerType())
			       ^
eventbus/kafka/eventbus.go:207:10: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"did not join group in time\")" (goerr113)
		return fmt.Errorf("did not join group in time")
		       ^
eventbus/redis/eventbus.go:168:10: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"could not create consumer group: %s\", res)" (goerr113)
		return fmt.Errorf("could not create consumer group: %s", res)
		       ^
eventhandler/projector/eventhandler_test.go:304:13: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"load error\")" (goerr113)
	loadErr := errors.New("load error")
	           ^
eventhandler/projector/eventhandler_test.go:333:13: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"save error\")" (goerr113)
	saveErr := errors.New("save error")
	           ^
eventhandler/projector/eventhandler_test.go:362:16: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"save error\")" (goerr113)
	projectErr := errors.New("save error")
	              ^
eventstore/memory/eventstore.go:138:15: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"invalid original version %d\", originalVersion)" (goerr113)
					BaseErr: fmt.Errorf("invalid original version %d", originalVersion),
					         ^
eventstore/mongodb/eventstore.go:62:15: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"missing DB client\")" (goerr113)
		return nil, fmt.Errorf("missing DB client")
		            ^
eventstore/mongodb/eventstore.go:165:14: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"invalid original version %d\", originalVersion)" (goerr113)
				BaseErr: fmt.Errorf("invalid original version %d", originalVersion),
				         ^
eventstore/mongodb_v2/eventstore.go:63:15: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"missing DB client\")" (goerr113)
		return nil, fmt.Errorf("missing DB client")
		            ^
eventstore/mongodb_v2/eventstore.go:219:17: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"inserted event %s at pos %d not found\",\n\tevent.AggregateID, event.Position)" (goerr113)
				return nil, fmt.Errorf("inserted event %s at pos %d not found",
				            ^
middleware/commandhandler/async/middleware_test.go:56:17: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"handling error\")" (goerr113)
	handlingErr := errors.New("handling error")
	               ^
middleware/commandhandler/scheduler/middleware_test.go:89:16: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"handler error\")" (goerr113)
	handlerErr := errors.New("handler error")
	              ^
middleware/commandhandler/scheduler/middleware_test.go:117:16: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"handler error\")" (goerr113)
	handlerErr := errors.New("handler error")
	              ^
middleware/commandhandler/validate/middleware_test.go:52:7: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"a validation error\")" (goerr113)
	e := errors.New("a validation error")
	     ^
middleware/eventhandler/async/middleware_test.go:57:17: err113: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"handling error\")" (goerr113)
	handlingErr := errors.New("handling error")
	               ^
namespace/eventstore.go:95:10: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"multiple errors: %s\", strings.Join(errStrs, \", \"))" (goerr113)
		return fmt.Errorf("multiple errors: %s", strings.Join(errStrs, ", "))
		       ^
namespace/repo.go:141:10: err113: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"multiple errors: %s\", strings.Join(errStrs, \", \"))" (goerr113)
		return fmt.Errorf("multiple errors: %s", strings.Join(errStrs, ", "))
		       ^
codec/acceptance_testing.go:54:12: mnd: Magic number: 42.0, in <assign> detected (gomnd)
		Number:  42.0,
		         ^
codec/acceptance_testing.go:62:12: mnd: Magic number: 42.0, in <assign> detected (gomnd)
			Number: 42.0,
			        ^
codec/acceptance_testing.go:67:12: mnd: Magic number: 42.0, in <assign> detected (gomnd)
			Number: 42.0,
			        ^
eventbus/acceptance_testing.go:139:44: mnd: Magic number: 2, in <argument> detected (gomnd)
		eh.ForAggregate(mocks.AggregateType, id, 2),
		                                         ^
eventbus/acceptance_testing.go:232:44: mnd: Magic number: 3, in <argument> detected (gomnd)
		eh.ForAggregate(mocks.AggregateType, id, 3),
		                                         ^
eventbus/acceptance_testing.go:274:34: mnd: Magic number: 20, in <argument> detected (gomnd)
	benchmark(&testAsBench{t}, bus, 20, 10, 1000)
	                                ^
eventbus/acceptance_testing.go:279:20: mnd: Magic number: 20, in <argument> detected (gomnd)
	benchmark(b, bus, 20, 10, b.N)
	                  ^
eventbus/acceptance_testing.go:330:23: mnd: Magic number: 30, in <argument> detected (gomnd)
				case <-time.After(30 * time.Second):
				                  ^
eventstore/acceptanece_testing.go:72:44: mnd: Magic number: 2, in <argument> detected (gomnd)
		eh.ForAggregate(mocks.AggregateType, id, 2),
		                                         ^
eventstore/acceptanece_testing.go:83:44: mnd: Magic number: 3, in <argument> detected (gomnd)
		eh.ForAggregate(mocks.AggregateType, id, 3))
		                                         ^
eventstore/acceptanece_testing.go:84:44: mnd: Magic number: 2, in <argument> detected (gomnd)
	err = store.Save(ctx, []eh.Event{event3}, 2)
	                                          ^
eventstore/acceptanece_testing.go:92:44: mnd: Magic number: 4, in <argument> detected (gomnd)
		eh.ForAggregate(mocks.AggregateType, id, 4))
		                                         ^
eventstore/acceptanece_testing.go:94:44: mnd: Magic number: 5, in <argument> detected (gomnd)
		eh.ForAggregate(mocks.AggregateType, id, 5))
		                                         ^
eventstore/acceptanece_testing.go:96:44: mnd: Magic number: 6, in <argument> detected (gomnd)
		eh.ForAggregate(mocks.AggregateType, id, 6))
		                                         ^
eventstore/acceptanece_testing.go:97:60: mnd: Magic number: 3, in <argument> detected (gomnd)
	err = store.Save(ctx, []eh.Event{event4, event5, event6}, 3)
	                                                          ^
eventstore/maintenance_testing.go:62:44: mnd: Magic number: 20, in <argument> detected (gomnd)
		eh.ForAggregate(mocks.AggregateType, id, 20))
		                                         ^
httputils/eventbus.go:77:28: mnd: Magic number: 10, in <argument> detected (gomnd)
	ch := make(chan eh.Event, 10)
	                          ^
hack/coverage/coverage.go:26:25: mnd: Magic number: 2, in <condition> detected (gomnd)
	} else if len(args) == 2 {
	                       ^
hack/coverage/coverage.go:65:21: mnd: Magic number: 3, in <condition> detected (gomnd)
			if len(parts) != 3 {
			                 ^
codec/bson/uuid.go:29:22: mnd: Magic number: 16, in <argument> detected (gomnd)
			b := make([]byte, 16)
			                  ^
eventbus/gcp/eventbus.go:55:43: mnd: Magic number: 100, in <argument> detected (gomnd)
		errCh:      make(chan eh.EventBusError, 100),
		                                        ^
eventbus/gcp/eventbus.go:163:20: mnd: Magic number: 256, in <condition> detected (gomnd)
	if len(filter) >= 256 {
	                  ^
eventbus/gcp/eventbus.go:176:28: mnd: Magic number: 60, in <assign> detected (gomnd)
				AckDeadline:           60 * time.Second,
				                       ^
eventbus/gcp/eventbus.go:180:22: mnd: Magic number: 3, in <assign> detected (gomnd)
					MinimumBackoff: 3 * time.Second,
					                ^
eventbus/kafka/eventbus.go:58:43: mnd: Magic number: 100, in <argument> detected (gomnd)
		errCh:      make(chan eh.EventBusError, 100),
		                                        ^
eventbus/kafka/eventbus.go:89:15: mnd: Magic number: 5, in <argument> detected (gomnd)
			time.Sleep(5 * time.Second)
			           ^
eventbus/kafka/eventbus.go:206:20: mnd: Magic number: 10, in <argument> detected (gomnd)
	case <-time.After(10 * time.Second):
	                  ^
eventbus/kafka/eventbus.go:84:24: mnd: Magic number: 5, in <assign> detected (gomnd)
				NumPartitions:     5,
				                   ^
eventbus/kafka/eventbus.go:188:26: mnd: Magic number: 100e3, in <assign> detected (gomnd)
		MaxBytes:              100e3,       // 100KB
		                       ^
eventbus/local/eventbus.go:51:43: mnd: Magic number: 100, in <argument> detected (gomnd)
		errCh:      make(chan eh.EventBusError, 100),
		                                        ^
eventbus/nats/eventbus.go:165:16: mnd: Magic number: 60, in <argument> detected (gomnd)
		nats.AckWait(60*time.Second),
		             ^
eventbus/nats/eventbus.go:166:19: mnd: Magic number: 10, in <argument> detected (gomnd)
		nats.MaxDeliver(10),
		                ^
repo/version/repo.go:71:8: mnd: Magic number: 5, in <assign> detected (gomnd)
		Max: 5 * time.Second,
		     ^
eventhandler/waiter/eventhandler_test.go:43:3: S1008: should use 'return event.EventType() == mocks.EventType' instead of 'if event.EventType() == mocks.EventType { return true }; return false' (gosimple)
		if event.EventType() == mocks.EventType {
		^
eventbus/nats/eventbus.go:201:2: S1000: should use for range instead of for { select {} } (gosimple)
	for {
	^
repo/version/repo_test.go:177:2: variable 'dt' is only used in the if-statement (repo/version/repo_test.go:181:2); consider using short syntax (ifshort)
	dt := time.Since(t1)
	^
repo/mongodb/repo_test.go:101:2: ineffectual assignment to result (ineffassign)
	result, err = r.FindCustom(ctx, func(ctx context.Context, c *mongo.Collection) (*mongo.Cursor, error) {
	^
eventbus/acceptance_testing.go:327:6: continue with no blank line before (nlreturn)
					continue
					^
eventbus/acceptance_testing.go:332:6: return with no blank line before (nlreturn)
					return
					^
httputils/command.go:33:4: return with no blank line before (nlreturn)
			return
			^
httputils/command.go:39:4: return with no blank line before (nlreturn)
			return
			^
httputils/eventbus.go:86:4: break with no blank line before (nlreturn)
			break
			^
httputils/eventbus.go:91:4: break with no blank line before (nlreturn)
			break
			^
eventbus/kafka/eventbus.go:90:4: continue with no blank line before (nlreturn)
			continue
			^
eventbus/kafka/eventbus.go:258:4: continue with no blank line before (nlreturn)
			continue
			^
eventstore/memory/eventmaintenance.go:45:4: break with no blank line before (nlreturn)
			break
			^
aggregate_test.go:25:1: Function TestCreateAggregate missing the call to method parallel (paralleltest)
func TestCreateAggregate(t *testing.T) {
^
aggregate_test.go:49:1: Function TestRegisterAggregateEmptyName missing the call to method parallel (paralleltest)
func TestRegisterAggregateEmptyName(t *testing.T) {
^
aggregate_test.go:60:1: Function TestRegisterAggregateNil missing the call to method parallel (paralleltest)
func TestRegisterAggregateNil(t *testing.T) {
^
aggregate_test.go:69:1: Function TestRegisterAggregateTwice missing the call to method parallel (paralleltest)
func TestRegisterAggregateTwice(t *testing.T) {
^
command_test.go:24:1: Function TestCreateCommand missing the call to method parallel (paralleltest)
func TestCreateCommand(t *testing.T) {
^
command_test.go:41:1: Function TestRegisterCommandEmptyName missing the call to method parallel (paralleltest)
func TestRegisterCommandEmptyName(t *testing.T) {
^
command_test.go:50:1: Function TestRegisterCommandNil missing the call to method parallel (paralleltest)
func TestRegisterCommandNil(t *testing.T) {
^
command_test.go:59:1: Function TestRegisterCommandTwice missing the call to method parallel (paralleltest)
func TestRegisterCommandTwice(t *testing.T) {
^
command_test.go:69:1: Function TestUnregisterCommandEmptyName missing the call to method parallel (paralleltest)
func TestUnregisterCommandEmptyName(t *testing.T) {
^
command_test.go:78:1: Function TestUnregisterCommandTwice missing the call to method parallel (paralleltest)
func TestUnregisterCommandTwice(t *testing.T) {
^
context_test.go:22:1: Function TestContextMarshaler missing the call to method parallel (paralleltest)
func TestContextMarshaler(t *testing.T) {
^
context_test.go:48:1: Function TestContextUnmarshaler missing the call to method parallel (paralleltest)
func TestContextUnmarshaler(t *testing.T) {
^
event_test.go:87:1: Function TestCreateEventData missing the call to method parallel (paralleltest)
func TestCreateEventData(t *testing.T) {
^
event_test.go:111:1: Function TestRegisterEventEmptyName missing the call to method parallel (paralleltest)
func TestRegisterEventEmptyName(t *testing.T) {
^
event_test.go:122:1: Function TestRegisterEventTwice missing the call to method parallel (paralleltest)
func TestRegisterEventTwice(t *testing.T) {
^
event_test.go:136:1: Function TestUnregisterEventEmptyName missing the call to method parallel (paralleltest)
func TestUnregisterEventEmptyName(t *testing.T) {
^
event_test.go:145:1: Function TestUnregisterEventTwice missing the call to method parallel (paralleltest)
func TestUnregisterEventTwice(t *testing.T) {
^
eventbus_test.go:23:1: Function TestEventBusError missing the call to method parallel (paralleltest)
func TestEventBusError(t *testing.T) {
^
eventbus_test.go:57:2: Range statement for test TestEventBusError missing the call to method parallel in test Run (paralleltest)
	for _, tc := range testCases {
	^
eventhandler_test.go:24:1: Function TestEventHandlerFunc missing the call to method parallel (paralleltest)
func TestEventHandlerFunc(t *testing.T) {
^
matcher_test.go:24:1: Function TestMatchEvents missing the call to method parallel (paralleltest)
func TestMatchEvents(t *testing.T) {
^
matcher_test.go:57:1: Function TestMatchAggregates missing the call to method parallel (paralleltest)
func TestMatchAggregates(t *testing.T) {
^
matcher_test.go:91:1: Function TestMatchAny missing the call to method parallel (paralleltest)
func TestMatchAny(t *testing.T) {
^
matcher_test.go:113:1: Function TestMatchAll missing the call to method parallel (paralleltest)
func TestMatchAll(t *testing.T) {
^
middleware_test.go:26:1: Function TestCommandHandlerMiddleware missing the call to method parallel (paralleltest)
func TestCommandHandlerMiddleware(t *testing.T) {
^
middleware_test.go:59:1: Function TestEventHandlerMiddleware missing the call to method parallel (paralleltest)
func TestEventHandlerMiddleware(t *testing.T) {
^
aggregatestore/events/aggregatebase_test.go:27:1: Function TestNewAggregateBase missing the call to method parallel (paralleltest)
func TestNewAggregateBase(t *testing.T) {
^
aggregatestore/events/aggregatebase_test.go:44:1: Function TestAggregateVersion missing the call to method parallel (paralleltest)
func TestAggregateVersion(t *testing.T) {
^
aggregatestore/events/aggregatestore_test.go:29:1: Function TestNewAggregateStore missing the call to method parallel (paralleltest)
func TestNewAggregateStore(t *testing.T) {
^
aggregatestore/events/aggregatestore_test.go:51:1: Function TestAggregateStore_LoadNoEvents missing the call to method parallel (paralleltest)
func TestAggregateStore_LoadNoEvents(t *testing.T) {
^
aggregatestore/events/aggregatestore_test.go:73:1: Function TestAggregateStore_LoadEvents missing the call to method parallel (paralleltest)
func TestAggregateStore_LoadEvents(t *testing.T) {
^
aggregatestore/events/aggregatestore_test.go:115:1: Function TestAggregateStore_LoadEvents_MismatchedEventType missing the call to method parallel (paralleltest)
func TestAggregateStore_LoadEvents_MismatchedEventType(t *testing.T) {
^
aggregatestore/events/aggregatestore_test.go:144:1: Function TestAggregateStore_SaveEvents missing the call to method parallel (paralleltest)
func TestAggregateStore_SaveEvents(t *testing.T) {
^
aggregatestore/events/aggregatestore_test.go:201:1: Function TestAggregateStore_AggregateNotRegistered missing the call to method parallel (paralleltest)
func TestAggregateStore_AggregateNotRegistered(t *testing.T) {
^
aggregatestore/model/aggregatestore_test.go:29:1: Function TestNewAggregateStore missing the call to method parallel (paralleltest)
func TestNewAggregateStore(t *testing.T) {
^
aggregatestore/model/aggregatestore_test.go:52:1: Function TestAggregateStore_LoadNotFound missing the call to method parallel (paralleltest)
func TestAggregateStore_LoadNotFound(t *testing.T) {
^
aggregatestore/model/aggregatestore_test.go:68:1: Function TestAggregateStore_Load missing the call to method parallel (paralleltest)
func TestAggregateStore_Load(t *testing.T) {
^
aggregatestore/model/aggregatestore_test.go:94:1: Function TestAggregateStore_Load_InvalidAggregate missing the call to method parallel (paralleltest)
func TestAggregateStore_Load_InvalidAggregate(t *testing.T) {
^
aggregatestore/model/aggregatestore_test.go:116:1: Function TestAggregateStore_Save missing the call to method parallel (paralleltest)
func TestAggregateStore_Save(t *testing.T) {
^
aggregatestore/model/aggregatestore_test.go:141:1: Function TestAggregateStore_SaveWithPublish missing the call to method parallel (paralleltest)
func TestAggregateStore_SaveWithPublish(t *testing.T) {
^
codec/bson/codec_test.go:24:1: Function TestEventCodec missing the call to method parallel (paralleltest)
func TestEventCodec(t *testing.T) {
^
codec/json/codec_test.go:24:1: Function TestEventCodec missing the call to method parallel (paralleltest)
func TestEventCodec(t *testing.T) {
^
commandhandler/aggregate/commandhandler_test.go:28:1: Function TestNewCommandHandler missing the call to method parallel (paralleltest)
func TestNewCommandHandler(t *testing.T) {
^
commandhandler/aggregate/commandhandler_test.go:49:1: Function TestCommandHandler missing the call to method parallel (paralleltest)
func TestCommandHandler(t *testing.T) {
^
commandhandler/aggregate/commandhandler_test.go:70:1: Function TestCommandHandler_AggregateNotFound missing the call to method parallel (paralleltest)
func TestCommandHandler_AggregateNotFound(t *testing.T) {
^
commandhandler/aggregate/commandhandler_test.go:92:1: Function TestCommandHandler_ErrorInHandler missing the call to method parallel (paralleltest)
func TestCommandHandler_ErrorInHandler(t *testing.T) {
^
commandhandler/aggregate/commandhandler_test.go:111:1: Function TestCommandHandler_ErrorWhenSaving missing the call to method parallel (paralleltest)
func TestCommandHandler_ErrorWhenSaving(t *testing.T) {
^
commandhandler/aggregate/commandhandler_test.go:126:1: Function TestCommandHandler_NoHandlers missing the call to method parallel (paralleltest)
func TestCommandHandler_NoHandlers(t *testing.T) {
^
commandhandler/bus/commandhandler_test.go:28:1: Function TestCommandHandler missing the call to method parallel (paralleltest)
func TestCommandHandler(t *testing.T) {
^
eventbus/gcp/eventbus_test.go:29:1: Function TestAddHandlerIntegration missing the call to method parallel (paralleltest)
func TestAddHandlerIntegration(t *testing.T) {
^
hack/coverage/coverage.go:19:2: SA4006: this value of `root` is never used (staticcheck)
	root, err := os.Getwd()
	^
repo/mongodb/repo.go:25:2: ST1019(related information): other import of "go.mongodb.org/mongo-driver/mongo/options" (stylecheck)
	mongoOptions "go.mongodb.org/mongo-driver/mongo/options"
	^
codec/json/codec.go:106:39: json(camel): got 'event_type' want 'eventType' (tagliatelle)
	EventType     eh.EventType           `json:"event_type"`
	                                     ^
codec/json/codec.go:110:39: json(camel): got 'aggregate_type' want 'aggregateType' (tagliatelle)
	AggregateType eh.AggregateType       `json:"aggregate_type"`
	                                     ^
codec/json/codec.go:111:39: json(camel): got 'aggregate_id' want 'aggregateId' (tagliatelle)
	AggregateID   string                 `json:"aggregate_id"`
	                                     ^
mocks/mocks.go:142:22: json(camel): got 'created_at' want 'createdAt' (tagliatelle)
	CreatedAt time.Time `json:"created_at" bson:"created_at"`
	                    ^
aggregate_test.go:15:9: package should be `eventhorizon_test` instead of `eventhorizon` (testpackage)
package eventhorizon
        ^
command_check_test.go:15:9: package should be `eventhorizon_test` instead of `eventhorizon` (testpackage)
package eventhorizon
        ^
command_test.go:15:9: package should be `eventhorizon_test` instead of `eventhorizon` (testpackage)
package eventhorizon
        ^
aggregatestore/events/aggregatebase_test.go:15:9: package should be `events_test` instead of `events` (testpackage)
package events
        ^
aggregatestore/events/aggregatestore_test.go:15:9: package should be `events_test` instead of `events` (testpackage)
package events
        ^
aggregatestore/model/aggregatestore_test.go:15:9: package should be `model_test` instead of `model` (testpackage)
package model
        ^
codec/bson/codec_test.go:15:9: package should be `bson_test` instead of `bson` (testpackage)
package bson
        ^
codec/json/codec_test.go:15:9: package should be `json_test` instead of `json` (testpackage)
package json
        ^
commandhandler/aggregate/commandhandler_test.go:15:9: package should be `aggregate_test` instead of `aggregate` (testpackage)
package aggregate
        ^
commandhandler/bus/commandhandler_test.go:15:9: package should be `bus_test` instead of `bus` (testpackage)
package bus
        ^
eventbus/gcp/eventbus_test.go:15:9: package should be `gcp_test` instead of `gcp` (testpackage)
package gcp
        ^
eventbus/kafka/eventbus_test.go:15:9: package should be `kafka_test` instead of `kafka` (testpackage)
package kafka
        ^
eventbus/local/eventbus_test.go:15:9: package should be `local_test` instead of `local` (testpackage)
package local
        ^
eventbus/nats/eventbus_test.go:15:9: package should be `nats_test` instead of `nats` (testpackage)
package nats
        ^
eventbus/redis/eventbus_test.go:15:9: package should be `redis_test` instead of `redis` (testpackage)
package redis
        ^
eventbus/tracing/eventbus_test.go:15:9: package should be `tracing_test` instead of `tracing` (testpackage)
package tracing
        ^
eventhandler/projector/eventhandler_test.go:15:9: package should be `projector_test` instead of `projector` (testpackage)
package projector
        ^
eventhandler/saga/eventhandler_test.go:15:9: package should be `saga_test` instead of `saga` (testpackage)
package saga
        ^
eventhandler/waiter/eventhandler_test.go:15:9: package should be `waiter_test` instead of `waiter` (testpackage)
package waiter
        ^
eventstore/memory/eventmaintenance_test.go:15:9: package should be `memory_test` instead of `memory` (testpackage)
package memory
        ^
eventstore/memory/eventstore_test.go:15:9: package should be `memory_test` instead of `memory` (testpackage)
package memory
        ^
eventstore/mongodb/eventmaintenance_test.go:15:9: package should be `mongodb_test` instead of `mongodb` (testpackage)
package mongodb
        ^
eventstore/mongodb/eventstore_test.go:15:9: package should be `mongodb_test` instead of `mongodb` (testpackage)
package mongodb
        ^
eventstore/recorder/eventstore_test.go:15:9: package should be `recorder_test` instead of `recorder` (testpackage)
package recorder
        ^
eventstore/tracing/eventstore_test.go:15:9: package should be `tracing_test` instead of `tracing` (testpackage)
package tracing
        ^
middleware/commandhandler/async/middleware_test.go:15:9: package should be `async_test` instead of `async` (testpackage)
package async
        ^
middleware/commandhandler/lock/middleware_test.go:15:9: package should be `lock_test` instead of `lock` (testpackage)
package lock
        ^
middleware/commandhandler/scheduler/middleware_test.go:15:9: package should be `scheduler_test` instead of `scheduler` (testpackage)
package scheduler
        ^
middleware/commandhandler/validate/middleware_test.go:15:9: package should be `validate_test` instead of `validate` (testpackage)
package validate
        ^
middleware/eventhandler/async/middleware_test.go:15:9: package should be `async_test` instead of `async` (testpackage)
package async
        ^
middleware/eventhandler/observer/middleware_test.go:15:9: package should be `observer_test` instead of `observer` (testpackage)
package observer
        ^
middleware/eventhandler/scheduler/middleware_test.go:15:9: package should be `scheduler_test` instead of `scheduler` (testpackage)
package scheduler
        ^
mocks/mocks_test.go:15:9: package should be `mocks_test` instead of `mocks` (testpackage)
package mocks
        ^
namespace/context_test.go:15:9: package should be `namespace_test` instead of `namespace` (testpackage)
package namespace
        ^
namespace/eventstore_test.go:15:9: package should be `namespace_test` instead of `namespace` (testpackage)
package namespace
        ^
namespace/repo_test.go:15:9: package should be `namespace_test` instead of `namespace` (testpackage)
package namespace
        ^
repo/cache/repo_test.go:15:9: package should be `cache_test` instead of `cache` (testpackage)
package cache
        ^
repo/memory/repo_test.go:15:9: package should be `memory_test` instead of `memory` (testpackage)
package memory
        ^
repo/mongodb/repo_test.go:15:9: package should be `mongodb_test` instead of `mongodb` (testpackage)
package mongodb
        ^
repo/tracing/repo_test.go:15:9: package should be `tracing_test` instead of `tracing` (testpackage)
package tracing
        ^
repo/version/context_test.go:15:9: package should be `version_test` instead of `version` (testpackage)
package version
        ^
repo/version/repo_test.go:15:9: package should be `version_test` instead of `version` (testpackage)
package version
        ^
codec/acceptance_testing.go:46:6: test helper function should start from t.Helper() (thelper)
func EventCodecAcceptanceTest(t *testing.T, c eh.EventCodec, expectedBytes []byte) {
     ^
eventbus/acceptance_testing.go:273:6: test helper function should start from t.Helper() (thelper)
func LoadTest(t *testing.T, bus eh.EventBus) {
     ^
aggregatestore/events/aggregatestore_test.go:216:6: test helper function should start from t.Helper() (thelper)
func createStore(t *testing.T) (*AggregateStore, *mocks.EventStore) {
     ^
middleware/eventhandler/tracing/middleware.go:53:9: error returned from interface method should be wrapped: sig: func (github.com/looplab/eventhorizon.EventHandler).HandleEvent(context.Context, github.com/looplab/eventhorizon.Event) error (wrapcheck)
	return err
	       ^
middleware/commandhandler/tracing/middleware.go:43:11: error returned from interface method should be wrapped: sig: func (github.com/looplab/eventhorizon.CommandHandler).HandleCommand(context.Context, github.com/looplab/eventhorizon.Command) error (wrapcheck)
			return err
			       ^
hack/coverage/coverage.go:87:11: error returned from external package is unwrapped: sig: func (*bufio.Scanner).Err() error (wrapcheck)
			return err
			       ^
hack/coverage/coverage.go:90:10: error returned from external package is unwrapped: sig: func os.Open(name string) (*os.File, error) (wrapcheck)
		return err
		       ^
aggregatestore/events/aggregatestore.go:85:15: error returned from external package is unwrapped: sig: func github.com/looplab/eventhorizon.CreateAggregate(aggregateType github.com/looplab/eventhorizon.AggregateType, id github.com/google/uuid.UUID) (github.com/looplab/eventhorizon.Aggregate, error) (wrapcheck)
		return nil, err
		            ^
aggregatestore/events/aggregatestore.go:94:15: error returned from interface method should be wrapped: sig: func (github.com/looplab/eventhorizon.EventStore).Load(context.Context, github.com/google/uuid.UUID) ([]github.com/looplab/eventhorizon.Event, error) (wrapcheck)
		return nil, err
		            ^
aggregatestore/events/aggregatestore.go:118:10: error returned from interface method should be wrapped: sig: func (github.com/looplab/eventhorizon.EventStore).Save(ctx context.Context, events []github.com/looplab/eventhorizon.Event, originalVersion int) error (wrapcheck)
		return err
		       ^
aggregatestore/model/aggregatestore.go:60:16: error returned from external package is unwrapped: sig: func github.com/looplab/eventhorizon.CreateAggregate(aggregateType github.com/looplab/eventhorizon.AggregateType, id github.com/google/uuid.UUID) (github.com/looplab/eventhorizon.Aggregate, error) (wrapcheck)
			return nil, err
			            ^
aggregatestore/model/aggregatestore.go:63:15: error returned from external package is unwrapped: sig: func github.com/looplab/eventhorizon.CreateAggregate(aggregateType github.com/looplab/eventhorizon.AggregateType, id github.com/google/uuid.UUID) (github.com/looplab/eventhorizon.Aggregate, error) (wrapcheck)
		return nil, err
		            ^
aggregatestore/model/aggregatestore.go:77:10: error returned from interface method should be wrapped: sig: func (github.com/looplab/eventhorizon.WriteRepo).Save(context.Context, github.com/looplab/eventhorizon.Entity) error (wrapcheck)
		return err
		       ^
aggregatestore/model/aggregatestore.go:86:12: error returned from interface method should be wrapped: sig: func (github.com/looplab/eventhorizon.EventHandler).HandleEvent(context.Context, github.com/looplab/eventhorizon.Event) error (wrapcheck)
				return err
				       ^
codec/bson/uuid.go:55:13: error returned from interface method should be wrapped: sig: func (go.mongodb.org/mongo-driver/bson/bsonrw.ValueReader).ReadString() (string, error) (wrapcheck)
					return err
					       ^
commandhandler/aggregate/commandhandler.go:59:10: error returned from external package is unwrapped: sig: func github.com/looplab/eventhorizon.CheckCommand(cmd github.com/looplab/eventhorizon.Command) error (wrapcheck)
		return err
		       ^
commandhandler/aggregate/commandhandler.go:64:10: error returned from interface method should be wrapped: sig: func (github.com/looplab/eventhorizon.AggregateStore).Load(context.Context, github.com/looplab/eventhorizon.AggregateType, github.com/google/uuid.UUID) (github.com/looplab/eventhorizon.Aggregate, error) (wrapcheck)
		return err
		       ^
commandhandler/aggregate/commandhandler.go:73:9: error returned from interface method should be wrapped: sig: func (github.com/looplab/eventhorizon.AggregateStore).Save(context.Context, github.com/looplab/eventhorizon.Aggregate) error (wrapcheck)
	return h.store.Save(ctx, a)
	       ^
commandhandler/bus/commandhandler.go:52:10: error returned from interface method should be wrapped: sig: func (github.com/looplab/eventhorizon.CommandHandler).HandleCommand(context.Context, github.com/looplab/eventhorizon.Command) error (wrapcheck)
		return handler.HandleCommand(ctx, cmd)
		       ^
eventbus/gcp/eventbus.go:75:15: error returned from external package is unwrapped: sig: func cloud.google.com/go/pubsub.NewClient(ctx context.Context, projectID string, opts ...google.golang.org/api/option.ClientOption) (c *cloud.google.com/go/pubsub.Client, err error) (wrapcheck)
		return nil, err
		            ^
eventbus/gcp/eventbus.go:82:15: error returned from external package is unwrapped: sig: func (*cloud.google.com/go/pubsub.Topic).Exists(ctx context.Context) (bool, error) (wrapcheck)
		return nil, err
		            ^
eventbus/gcp/eventbus.go:85:16: error returned from external package is unwrapped: sig: func (*cloud.google.com/go/pubsub.Client).CreateTopic(ctx context.Context, topicID string) (*cloud.google.com/go/pubsub.Topic, error) (wrapcheck)
			return nil, err
			            ^
eventbus/gcp/eventbus.go:222:9: error returned from external package is unwrapped: sig: func (*cloud.google.com/go/pubsub.Client).Close() error (wrapcheck)
	return b.client.Close()
	       ^
eventbus/kafka/eventbus.go:229:9: error returned from external package is unwrapped: sig: func (*github.com/segmentio/kafka-go.Writer).Close() error (wrapcheck)
	return b.writer.Close()
	       ^
eventbus/redis/eventbus.go:190:9: error returned from external package is unwrapped: sig: func (*github.com/go-redis/redis/v8.baseClient).Close() error (wrapcheck)
	return b.client.Close()
	       ^
eventbus/tracing/eventbus.go:42:9: error returned from interface method should be wrapped: sig: func (github.com/looplab/eventhorizon.EventHandler).HandleEvent(context.Context, github.com/looplab/eventhorizon.Event) error (wrapcheck)
	return b.h.HandleEvent(ctx, event)
	       ^
eventhandler/saga/eventhandler_test.go:70:10: error returned from interface method should be wrapped: sig: func (github.com/looplab/eventhorizon.CommandHandler).HandleCommand(context.Context, github.com/looplab/eventhorizon.Command) error (wrapcheck)
		return h.HandleCommand(ctx, cmd)
		       ^
eventhandler/waiter/eventhandler.go:86:15: error returned from interface method should be wrapped: sig: func (context.Context).Err() error (wrapcheck)
		return nil, ctx.Err()
		            ^
eventstore/mongodb/eventstore.go:234:9: error returned from external package is unwrapped: sig: func (*go.mongodb.org/mongo-driver/mongo.Client).Disconnect(ctx context.Context) error (wrapcheck)
	return s.client.Disconnect(context.Background())
	       ^
eventstore/mongodb_v2/eventmaintenance.go:48:16: error returned from external package is unwrapped: sig: func (*go.mongodb.org/mongo-driver/mongo.Collection).CountDocuments(ctx context.Context, filter interface{}, opts ...*go.mongodb.org/mongo-driver/mongo/options.CountOptions) (int64, error) (wrapcheck)
			return nil, err
			            ^
eventstore/mongodb_v2/eventmaintenance.go:80:16: error returned from external package is unwrapped: sig: func (*go.mongodb.org/mongo-driver/mongo.Collection).ReplaceOne(ctx context.Context, filter interface{}, replacement interface{}, opts ...*go.mongodb.org/mongo-driver/mongo/options.ReplaceOptions) (*go.mongodb.org/mongo-driver/mongo.UpdateResult, error) (wrapcheck)
			return nil, err
			            ^
eventstore/mongodb_v2/eventmaintenance.go:88:11: error returned from interface method should be wrapped: sig: func (go.mongodb.org/mongo-driver/mongo.Session).WithTransaction(ctx context.Context, fn func(sessCtx go.mongodb.org/mongo-driver/mongo.SessionContext) (interface{}, error), opts ...*go.mongodb.org/mongo-driver/mongo/options.TransactionOptions) (interface{}, error) (wrapcheck)
			return err
			       ^
eventstore/mongodb_v2/eventstore.go:321:9: error returned from external package is unwrapped: sig: func (*go.mongodb.org/mongo-driver/mongo.Client).Disconnect(ctx context.Context) error (wrapcheck)
	return s.client.Disconnect(context.Background())
	       ^
eventstore/recorder/eventstore.go:91:10: error returned from interface method should be wrapped: sig: func (github.com/looplab/eventhorizon.EventStore).Save(ctx context.Context, events []github.com/looplab/eventhorizon.Event, originalVersion int) error (wrapcheck)
		return err
		       ^
eventstore/tracing/eventstore.go:60:9: error returned from interface method should be wrapped: sig: func (github.com/looplab/eventhorizon.EventStore).Save(ctx context.Context, events []github.com/looplab/eventhorizon.Event, originalVersion int) error (wrapcheck)
	return err
	       ^
eventstore/tracing/eventstore.go:81:17: error returned from interface method should be wrapped: sig: func (github.com/looplab/eventhorizon.EventStore).Load(context.Context, github.com/google/uuid.UUID) ([]github.com/looplab/eventhorizon.Event, error) (wrapcheck)
	return events, err
	               ^
middleware/commandhandler/lock/middleware.go:30:12: error returned from interface method should be wrapped: sig: func (github.com/looplab/eventhorizon/middleware/commandhandler/lock.Lock).Lock(id string) error (wrapcheck)
				return err
				       ^
middleware/eventhandler/scheduler/middleware.go:55:10: error returned from interface method should be wrapped: sig: func (context.Context).Err() error (wrapcheck)
		return err
		       ^
middleware/eventhandler/scheduler/middleware.go:60:10: error returned from external package is unwrapped: sig: func github.com/gorhill/cronexpr.Parse(cronLine string) (*github.com/gorhill/cronexpr.Expression, error) (wrapcheck)
		return err
		       ^
middleware/eventhandler/scheduler/middleware.go:100:12: error returned from external package is unwrapped: sig: func (github.com/looplab/eventhorizon.EventHandler).HandleEvent(context.Context, github.com/looplab/eventhorizon.Event) error (wrapcheck)
				return err
				       ^
middleware/eventhandler/scheduler/middleware.go:104:12: error returned from interface method should be wrapped: sig: func (context.Context).Err() error (wrapcheck)
				return err
				       ^
namespace/eventstore_test.go:34:16: error returned from external package is unwrapped: sig: func github.com/looplab/eventhorizon/eventstore/memory.NewEventStore(options ...github.com/looplab/eventhorizon/eventstore/memory.Option) (*github.com/looplab/eventhorizon/eventstore/memory.EventStore, error) (wrapcheck)
			return nil, err
			            ^
repo/cache/repo.go:91:15: error returned from interface method should be wrapped: sig: func (github.com/looplab/eventhorizon.ReadRepo).Find(context.Context, github.com/google/uuid.UUID) (github.com/looplab/eventhorizon.Entity, error) (wrapcheck)
		return nil, err
		            ^
repo/cache/repo.go:104:15: error returned from interface method should be wrapped: sig: func (github.com/looplab/eventhorizon.ReadRepo).FindAll(context.Context) ([]github.com/looplab/eventhorizon.Entity, error) (wrapcheck)
		return nil, err
		            ^
repo/cache/repo.go:124:9: error returned from interface method should be wrapped: sig: func (github.com/looplab/eventhorizon.WriteRepo).Save(context.Context, github.com/looplab/eventhorizon.Entity) error (wrapcheck)
	return r.ReadWriteRepo.Save(ctx, entity)
	       ^
repo/cache/repo.go:134:9: error returned from interface method should be wrapped: sig: func (github.com/looplab/eventhorizon.WriteRepo).Remove(context.Context, github.com/google/uuid.UUID) error (wrapcheck)
	return r.ReadWriteRepo.Remove(ctx, id)
	       ^
repo/mongodb/repo.go:202:10: error returned from external package is unwrapped: sig: func (*go.mongodb.org/mongo-driver/mongo.Cursor).Close(ctx context.Context) error (wrapcheck)
		return err
		       ^
repo/mongodb/repo.go:361:9: error returned from external package is unwrapped: sig: func (*go.mongodb.org/mongo-driver/mongo.Client).Disconnect(ctx context.Context) error (wrapcheck)
	return r.client.Disconnect(context.Background())
	       ^
repo/mongodb/repo_test.go:91:10: error returned from external package is unwrapped: sig: func (*go.mongodb.org/mongo-driver/mongo.Collection).Find(ctx context.Context, filter interface{}, opts ...*go.mongodb.org/mongo-driver/mongo/options.FindOptions) (*go.mongodb.org/mongo-driver/mongo.Cursor, error) (wrapcheck)
		return c.Find(ctx, bson.M{"content": "modelCustom"})
		       ^
repo/mongodb/repo_test.go:146:10: error returned from external package is unwrapped: sig: func (*go.mongodb.org/mongo-driver/mongo.Collection).Find(ctx context.Context, filter interface{}, opts ...*go.mongodb.org/mongo-driver/mongo/options.FindOptions) (*go.mongodb.org/mongo-driver/mongo.Cursor, error) (wrapcheck)
		return c.Find(ctx, bson.M{"content": "modelCustom"})
		       ^
repo/tracing/repo.go:69:17: error returned from interface method should be wrapped: sig: func (github.com/looplab/eventhorizon.ReadRepo).Find(context.Context, github.com/google/uuid.UUID) (github.com/looplab/eventhorizon.Entity, error) (wrapcheck)
	return entity, err
	               ^
repo/tracing/repo.go:83:19: error returned from interface method should be wrapped: sig: func (github.com/looplab/eventhorizon.ReadRepo).FindAll(context.Context) ([]github.com/looplab/eventhorizon.Entity, error) (wrapcheck)
	return entities, err
	                 ^
repo/tracing/repo.go:98:9: error returned from interface method should be wrapped: sig: func (github.com/looplab/eventhorizon.WriteRepo).Save(context.Context, github.com/looplab/eventhorizon.Entity) error (wrapcheck)
	return err
	       ^
